package etcd

func (f *EtcdFilter) tlsTemplates() map[string]string {
	return map[string]string{
		"tls-job":         tlsJobTemplate,
		"tls-sa":          tlsSATemplate,
		"tls-role":        tlsRoleTemplate,
		"tls-rolebinding": tlsRoleBindingTemplate,
	}
}

var cfsslCMTemplate = `apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Name }}-cfssl
  namespace: "{{ .Namespace }}"
  labels:
    app.kubernetes.io/name: {{ index .Labels "app.kubernetes.io/name" }}
    app.kubernetes.io/instance: {{ index .Labels "app.kubernetes.io/instance" }}
data:
  secret_name: {{ .Name }}-cfssl
  config.json: |-
    {
      "signing": {
        "default": {
          "expiry": "43800h"
        },
        "profiles": {
          "client": {
            "expiry": "43800h",
            "usages": [
              "signing",
              "key encipherment",
              "client auth"
            ]
          },
          "server": {
            "expiry": "43800h",
            "usages": [
              "signing",
              "key encipherment",
              "server auth",
              "client auth"
            ]
          },
          "peer": {
            "expiry": "43800h",
            "usages": [
              "signing",
              "key encipherment",
              "server auth",
              "client auth"
            ]
          }
        }
      }
    }
  ca_csr.json: |-
    {
      "CN": "Autogenerated CA",
      "key": {
        "algo": "rsa",
        "size": 2048
      },
      "names": [
        {
          "C": "US",
          "ST": "CA",
          "L": "San Francisco",
          "O": "Autogen CA for Etcd"
        }
      ]
    }
  root_client_csr.json: |-
    {
      "CN": "root",
      "hosts": [""],
      "key": {
        "algo": "rsa",
        "size": 2048
      },
      "names": [
        {
          "C": "US",
          "ST": "CA",
          "L": "San Francisco"
        }
      ]
    }
{{ range $i, $hostname := .Data.Hostnames }}
  {{ $i }}_server_csr.json: |-
    {
      "CN": "etcd-server",
      "hosts": [
        "::1",
        "127.0.0.1",
        "localhost",
        "{{ $.Name }}-server",
        "{{ $.Name }}-server.{{ $.Namespace }}.svc",
        "{{ $hostname }}",
        "{{ $hostname }}.{{ $.Name }}-server"
      ],
      "key": {
        "algo": "rsa",
        "size": 2048
      },
      "names": [
        {
          "C": "US",
          "ST": "CA",
          "L": "San Francisco"
        }
      ]
    }
{{ end }}
{{ range $i, $hostname := .Data.Hostnames }}
  {{ $i }}_peer_csr.json: |-
    {
      "CN": "etcd-peer",
      "hosts": [
        "::1",
        "127.0.0.1",
        "localhost",
        "{{ $.Name }}-server",
        "{{ $.Name }}-server.{{ $.Namespace }}.svc",
        "{{ $hostname }}",
        "{{ $hostname }}.{{ $.Name }}-server"
      ],
      "key": {
        "algo": "rsa",
        "size": 2048
      },
      "names": [
        {
          "C": "US",
          "ST": "CA",
          "L": "San Francisco"
        }
      ]
    }
{{ end }}
`

var tlsJobTemplate = `apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Name }}-tls
  namespace: "{{ .Namespace }}"
  labels:
    app.kubernetes.io/name: {{ index .Labels "app.kubernetes.io/name" }}
    app.kubernetes.io/instance: {{ index .Labels "app.kubernetes.io/instance" }}
spec:
  template:
    spec:
      serviceAccountName: {{ .Name }}-tls
      restartPolicy: OnFailure
      containers:
        - name: create-tls-secrets
          image: k8s.gcr.io/hyperkube:v1.17.2
          command:
            - /bin/sh
            - -ec
            - |-
              secret="$(tls_server_secret_name)"
              mkdir /tls-server
              cp /tls/*-server*.pem /tls-server
              cp /tls/*-peer*.pem /tls-server
              kubectl create secret generic "${secret}" --from-file=/tls-server

              secret="$(tls_ca_secret_name)"
              kubectl create secret generic "${secret}" \
                "--from-file=/tls/ca-key.pem" \
                "--from-file=/tls/ca.pem"

              secret="$(tls_root_client_secret_name)"
              kubectl create secret generic "${secret}" \
                "--from-file=/tls/root-client-key.pem" \
                "--from-file=/tls/root-client.pem"
          envFrom:
            - configMapRef:
                name: {{ .Name }}
          volumeMounts:
            - mountPath: /tls
              name: etcd-cfssl
      volumes:
        - name: etcd-cfssl
          secret:
            secretName: {{ .Name }}-cfssl
`

// RBAC
var tlsSATemplate = `apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Name }}-tls
  namespace: "{{ .Namespace }}"
  labels:
    app.kubernetes.io/name: {{ index .Labels "app.kubernetes.io/name" }}
    app.kubernetes.io/instance: {{ index .Labels "app.kubernetes.io/instance" }}
`

var tlsRoleTemplate = `apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ .Name }}-tls
  namespace: "{{ .Namespace }}"
  labels:
    app.kubernetes.io/name: {{ index .Labels "app.kubernetes.io/name" }}
    app.kubernetes.io/instance: {{ index .Labels "app.kubernetes.io/instance" }}
rules:
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - create
`

var tlsRoleBindingTemplate = `apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ .Name }}-tls
  namespace: "{{ .Namespace }}"
  labels:
    app.kubernetes.io/name: {{ index .Labels "app.kubernetes.io/name" }}
    app.kubernetes.io/instance: {{ index .Labels "app.kubernetes.io/instance" }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ .Name }}-tls
subjects:
  - kind: ServiceAccount
    name: {{ .Name }}-tls
`
